#summary Features to be Implemented
#labels backlog

= Collection Theme =
 * A lot more Extended  Collections (curryed ones, like ruby 1.9, sortBy, partition, and lazy collect, lazy map etc): ??? points
 * Wrapped extended collections: 9 points
 * Wrapped over Fork Join: 10 points

= Closures Theme =
 * Full Coercion (includes detecting [http://docs.google.com/View?docid=k73_1ggr36h& SAMs] generated from Abstract Classes instead of Interfaces): 10  points
 * Numargs method: 5 points
 * .asThread: 2 points
 * !TimeIt: 4  points
 * Compose: 6 points
 * Curry: 1 point

= To think about it (need points and priorization) =
 * [http://en.wikipedia.org/wiki/Schwartzian_transform Schwartzian_transform] on sort_by
 * sort_with_keys (python influence). Receiving a closure, of course.
 * Standard coercion to runnable and callable. One liner, with [http://fluentjava.googlecode.com/svn/trunk/apidocs/org/fluentjava/closures/Closure.html#toInteface(java.lang.Class) to interface]
 * Softening exceptions (on Closure)
 * Make it javac friendly (type inference on instance methods is incredible on eclipse compiler). Maybe I should make a wiki page about it?
 * range and xrange from python, on fluency
 * Fluency delegator
 * Static fluency methods. Thinking about an Aspectj Aspect to make things like _my_ callable from static methods without one single argument (for those who won't/can't/don't like/don't feel like it/are grossed out about extending a third party class).
 * Arithmethic operations (smalltalk inspiration, again) on enumerable
 * fluent set operations. possibly both immutable and muttable
 * Partiation and iterablePartition on list
 * Ruby's hash constructor (maybe extended interface on map, as the defaults do not allow this):
{{{
Hash.new => hash
Hash.new(obj) => aHash
Hash.new {|hash, key| block } => aHash
}}}

== Mini release (0.21) ==
=== Done ===
 * coercion de string para ClosureOfAString
 * static fluent utils (from fluency)
 * move Pair from iterators to collections
 * better lookup strategy to ClosureOfAString

=== Working ===
 * fluency delegator
 * range(10), range(1, 10), and iterable versions
 * hamcrest support (too many good almost closures there)
 
=== Won't be Done ===
 * cache to o closure of a string